{"ast":null,"code":"'use strict'; // Dependencies\n\nvar path = require('path'); // Load global paths\n\n\nvar globalPaths = require('module').globalPaths; // Guess at NPM's global install dir\n\n\nvar npmGlobalPrefix;\n\nif ('win32' === process.platform) {\n  npmGlobalPrefix = path.dirname(process.execPath);\n} else {\n  npmGlobalPrefix = path.dirname(path.dirname(process.execPath));\n}\n\nvar npmGlobalModuleDir = path.resolve(npmGlobalPrefix, 'lib', 'node_modules'); // Save OS-specific path separator\n\nvar sep = path.sep; // If we're in webpack, force it to use the original require() method\n\nvar requireFunction = \"function\" === typeof __webpack_require__ || \"function\" === typeof __non_webpack_require__ ? __non_webpack_require__ : require;\n\nconst isInstalledWithPNPM = function (resolved) {\n  const pnpmDir = sep + '.pnpm';\n\n  for (const globalPath of globalPaths) {\n    if (-1 !== globalPath.indexOf(pnpmDir) && -1 !== resolved.indexOf(pnpmDir)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst getFirstPartFromNodeModules = function (resolved) {\n  const nodeModulesDir = sep + 'node_modules';\n\n  if (-1 !== resolved.indexOf(nodeModulesDir)) {\n    const parts = resolved.split(nodeModulesDir);\n\n    if (parts.length) {\n      return parts[0];\n    }\n  }\n\n  return null;\n}; // Resolver\n\n\nmodule.exports = function resolve(dirname) {\n  // Check for environmental variable\n  if (process.env.APP_ROOT_PATH) {\n    return path.resolve(process.env.APP_ROOT_PATH);\n  } // Defer to Yarn Plug'n'Play if enabled\n\n\n  if (process.versions.pnp) {\n    try {\n      var pnp = requireFunction('pnpapi');\n      return pnp.getPackageInformation(pnp.topLevel).packageLocation;\n    } catch (e) {}\n  } // Defer to main process in electron renderer\n\n\n  if ('undefined' !== typeof window && window.process && 'renderer' === window.process.type) {\n    try {\n      var remote = requireFunction('electron').remote;\n      return remote.require('app-root-path').path;\n    } catch (e) {}\n  } // Defer to AWS Lambda when executing there\n\n\n  if (process.env.LAMBDA_TASK_ROOT && process.env.AWS_EXECUTION_ENV) {\n    return process.env.LAMBDA_TASK_ROOT;\n  }\n\n  var resolved = path.resolve(dirname);\n  var alternateMethod = false;\n  var appRootPath = null; // Check if the globalPaths contain some folders with '.pnpm' in the path\n  // If yes this means it is most likely installed with pnpm\n\n  if (isInstalledWithPNPM(resolved)) {\n    appRootPath = getFirstPartFromNodeModules(resolved);\n\n    if (appRootPath) {\n      return appRootPath;\n    }\n  } // Make sure that we're not loaded from a global include path\n  // Eg. $HOME/.node_modules\n  //     $HOME/.node_libraries\n  //     $PREFIX/lib/node\n\n\n  globalPaths.forEach(function (globalPath) {\n    if (!alternateMethod && 0 === resolved.indexOf(globalPath)) {\n      alternateMethod = true;\n    }\n  }); // If the app-root-path library isn't loaded globally,\n  // and node_modules exists in the path, just split __dirname\n\n  if (!alternateMethod) {\n    appRootPath = getFirstPartFromNodeModules(resolved);\n  } // If the above didn't work, or this module is loaded globally, then\n  // resort to require.main.filename (See http://nodejs.org/api/modules.html)\n\n\n  if (alternateMethod || null == appRootPath) {\n    appRootPath = path.dirname(requireFunction.main.filename);\n  } // Handle global bin/ directory edge-case\n\n\n  if (alternateMethod && -1 !== appRootPath.indexOf(npmGlobalModuleDir) && appRootPath.length - 4 === appRootPath.indexOf(sep + 'bin')) {\n    appRootPath = appRootPath.slice(0, -4);\n  } // Return\n\n\n  return appRootPath;\n};","map":{"version":3,"sources":["C:/Users/Mihai/Desktop/Projects/GIT/WolvesProject/wolves-project/node_modules/app-root-path/lib/resolve.js"],"names":["path","require","globalPaths","npmGlobalPrefix","process","platform","dirname","execPath","npmGlobalModuleDir","resolve","sep","requireFunction","__webpack_require__","__non_webpack_require__","isInstalledWithPNPM","resolved","pnpmDir","globalPath","indexOf","getFirstPartFromNodeModules","nodeModulesDir","parts","split","length","module","exports","env","APP_ROOT_PATH","versions","pnp","getPackageInformation","topLevel","packageLocation","e","window","type","remote","LAMBDA_TASK_ROOT","AWS_EXECUTION_ENV","alternateMethod","appRootPath","forEach","main","filename","slice"],"mappings":"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","sourcesContent":["'use strict';\n\n// Dependencies\nvar path = require('path');\n\n// Load global paths\nvar globalPaths = require('module').globalPaths;\n\n// Guess at NPM's global install dir\nvar npmGlobalPrefix;\nif ('win32' === process.platform) {\n\tnpmGlobalPrefix = path.dirname(process.execPath);\n} else {\n\tnpmGlobalPrefix = path.dirname(path.dirname(process.execPath));\n}\nvar npmGlobalModuleDir = path.resolve(npmGlobalPrefix, 'lib', 'node_modules');\n\n// Save OS-specific path separator\nvar sep = path.sep;\n\n// If we're in webpack, force it to use the original require() method\nvar requireFunction = (\"function\" === typeof __webpack_require__ || \"function\" === typeof __non_webpack_require__)\n\t? __non_webpack_require__\n\t: require;\n\nconst isInstalledWithPNPM = function(resolved) {\n\tconst pnpmDir = sep + '.pnpm';\n\n\tfor (const globalPath of globalPaths) {\n\t\tif (-1 !== globalPath.indexOf(pnpmDir) && -1 !== resolved.indexOf(pnpmDir)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nconst getFirstPartFromNodeModules = function(resolved) {\n\tconst nodeModulesDir = sep + 'node_modules';\n\n\tif (-1 !== resolved.indexOf(nodeModulesDir)) {\n\t\tconst parts = resolved.split(nodeModulesDir);\n\t\tif (parts.length) {\n\t\t\treturn parts[0];\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Resolver\nmodule.exports = function resolve(dirname) {\n\t// Check for environmental variable\n\tif (process.env.APP_ROOT_PATH) {\n\t\treturn path.resolve(process.env.APP_ROOT_PATH);\n\t}\n\n\t// Defer to Yarn Plug'n'Play if enabled\n\tif (process.versions.pnp) {\n\t\ttry {\n\t\t\tvar pnp = requireFunction('pnpapi');\n\t\t\treturn pnp.getPackageInformation(pnp.topLevel).packageLocation;\n\t\t} catch (e) {}\n\t}\n\n\t// Defer to main process in electron renderer\n\tif ('undefined' !== typeof window && window.process && 'renderer' === window.process.type) {\n\t\ttry {\n\t\t\tvar remote = requireFunction('electron').remote;\n\t\t\treturn remote.require('app-root-path').path;\n\t\t} catch (e) {}\n\t}\n\n\t// Defer to AWS Lambda when executing there\n\tif (process.env.LAMBDA_TASK_ROOT && process.env.AWS_EXECUTION_ENV) {\n\t\treturn process.env.LAMBDA_TASK_ROOT;\n\t}\n\n\tvar resolved = path.resolve(dirname);\n\tvar alternateMethod = false;\n\tvar appRootPath = null;\n\n\t// Check if the globalPaths contain some folders with '.pnpm' in the path\n\t// If yes this means it is most likely installed with pnpm\n\tif (isInstalledWithPNPM(resolved)) {\n\t\tappRootPath = getFirstPartFromNodeModules(resolved);\n\n\t\tif (appRootPath) {\n\t\t\treturn appRootPath;\n\t\t}\n\t}\n\n\t// Make sure that we're not loaded from a global include path\n\t// Eg. $HOME/.node_modules\n\t//     $HOME/.node_libraries\n\t//     $PREFIX/lib/node\n\tglobalPaths.forEach(function(globalPath) {\n\t\tif (!alternateMethod && 0 === resolved.indexOf(globalPath)) {\n\t\t\talternateMethod = true;\n\t\t}\n\t});\n\n\t// If the app-root-path library isn't loaded globally,\n\t// and node_modules exists in the path, just split __dirname\n\tif (!alternateMethod) {\n\t\tappRootPath = getFirstPartFromNodeModules(resolved);\n\t}\n\n\t// If the above didn't work, or this module is loaded globally, then\n\t// resort to require.main.filename (See http://nodejs.org/api/modules.html)\n\tif (alternateMethod || null == appRootPath) {\n\t\tappRootPath = path.dirname(requireFunction.main.filename);\n\t}\n\n\t// Handle global bin/ directory edge-case\n\tif (alternateMethod && -1 !== appRootPath.indexOf(npmGlobalModuleDir) && (appRootPath.length - 4) === appRootPath.indexOf(sep + 'bin')) {\n\t\tappRootPath = appRootPath.slice(0, -4);\n\t}\n\n\t// Return\n\treturn appRootPath;\n};\n"]},"metadata":{},"sourceType":"script"}